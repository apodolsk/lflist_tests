The goal of del(a) is to approximate an impossible atomic operation:
    [Set p->n = n
         n->p = p
     iff a->n == n
         a->p == p
         p->n == a
         n->p == a]

There's probably no choice but to use two (CAS2) writes: on p->n, then on
n->p. The p->n write probably shouldn't act on stale information, lest the
list become a jumble of "spuriously" written pointers which need
potentially "spurious" correcting. So del(a) has the following key
property P1:

A p->n = n write succeeds only if a->n == n.

The trick to this is that a->n records whether any pn writes due to del(a)
are in flight; interested parties use this to deduce whether all such
writes are bound to fail.

In particular, between its a read and its pn write, del(a) sets a->n.st =
COMMIT and increments a->n.gen. The rule is that a locked a->n can't be
written except to unlock it, and it can only be unlocked if all writes are
bound to fail.

If a del(n) finds a->n unlocked, then it simply writes a->n and P1 holds.

If it finds a->n locked and p->n unlocked, then it helps the del(n),
writing pn and np.

If it finds both locked, it'd be nice to [unlock a->n iff p->n is still
locked], but this is probably impossible. Instead, del(n) uses version
counters to deduce whether all pn writes on behalf of del(a) are bound to
fail. Iff so, it unlocks a->n and then continues as if it had found an
unlocked a->n to begin.

In more detail: del(a) locks a->n after it reads p->n, and del(n) reads
a->n before it reads p->n. If del(n) finds a->n.gen unchanged after its
p->n read, it must be that every del(a) committed to a pn write read pn
before del(n). They must have found pn unlocked, or they wouldn't have
committed, and their writes



ith version counters and
careful ordering of operations, del(n) can decide whether all writes to 

exploits version
counters to decide whether

. Without the
separate unlocking step, a del(n->n) might see a->n locked and falsely
assume that del(n) is bound to fail, even though del(n) is about to
simultaneously unlock unlocking step is
necessary so that a del(n->n) can accurately judge
whether del(n) is bound to fail.

can accurately judge
whether del(n) can be helped. 

So just by
looking at a->n, del(n) can 




If it finds a->n locked, the scheme is subtle. 


an advertisement step in del(a). Between its a read
and its pn write, del(a) sets n

del(a) 

It gets this with a scheme akin to locking. Between its read of a and its
write of p->n, del(a) essentially sets a lock bit on a->n. Nobody modifies
the pointer in a->n if it's locked. 

The hard part is that del(a) should be able to able to make progress if
p->n is locked. In this case, a del(p) must be in flight.

Iff ppn := &p->p->n isn't locked, del(a) simply helps del(p) by writing
ppn and a->p.

If del(a) finds ppn locked, the case is harder. del(p) can't (trivially)
be helped. Instead, del(a) exploits the fact that del(p)'s ppn write
attempt is doomed on account of the lock. It races to unlock and write
p->n before del(p) restarts.

The subtlety is that del(a) can't atomically find ppn locked and unlock
p->n. However, the list is set up so that del(a) can deduce whether all
ppn reads by del(p) are bound to fail, just by accessing p->n. In
particular, it uses version counts to tell

a->n.gen is incremented on every a->n write, including to the "lock bit"

The scheme for this 

p->n can tell whether ppn is locked. 
del(a) whether ppn is locked. This means : unlock p->n iff all writes on
behalf of del(p) are bound to fail. The trick to this is essentially
version counting of *reads*.

In particular, every time a del(p) locks p->n, it increments a version
count on a->n. del(a) reads the version count, then finds p->p->n locked,
and atomically unlocks p->n iff the version count is unchanged. If

This is the main trick of the lflist.

An alternate scheme might be to

The next goal is to make progress if p->n is locked.

The 

The trick to this is that . It's illustrative to view this in terms of
locking. del(a) locks a->n when it advertises intent to write p->n. Before
anyone can write a->n, they must attempt to help the locker. 

enq(a) reuses this trick, and even the code which achieves it.

each node records whether a deletion

There's no atomic primitive for this, del(a) should approximate it
somehow. It does this with two CAS2 writes: on p->n, and then on
n->p. This is roughly equivalent because:
  - The p->n write succeeds iff all conditions listed above hold. 
  - If the p->n write succeeds, almost all conditions will hold until the
    n->p write. The exception is just that p->n == a instead of p->n == n.

There's a total order of CAS2 writes and all writes to lflist nodes are
CAS2. I say "time t" to mean any time between writes t and t+1.
  - NB: initialization is non-atomic. Brush that under the rug.

At each time t, for each node a:

Let flx p = a->p.
    flx n = a->n.

IH1
One of the following predicates must hold. They're mutually exclusive, so
you can talk about the states defined by these predicates.

Q(a) (quiescent):
    p->n == a &&
    (n->p == a || n->p->p == a) &&
    n.st != COMMIT &&
    p.st != COMMIT 

C(a) (del() committed to p->n write attempt):
    p->n == a &&
    n->p == a &&
    n.st == COMMIT &&
    p.st != COMMIT 

DP(a) (del() wrote p->n, about to write n->p)
    p->n == n &&
    n->p == a &&
    n.st == COMMIT &&
    p.st != COMMIT &&

DN(a) (del() wrote n->p)
    n.st == COMMIT &&
    p->n != a &&
    n->p != a &&
    p.st != COMMIT

D(a) (deleted):
    p.st == COMMIT
    p->n != a
    n->p != a

IH2
If Q(a) || C(a), then Q(n) || C(n).

IH3
If Q(a) || C(a) || DP(a), then there's exactly one node a2 such that:
    Q(a) || C(a) &&
    a2->p == a

Every write to a->n assigns a unique value to a->n.gen.

Every enq(a) assigns a unique value to a->p.gen.

The goal of del(a) is to reach D(a), if possible. 

Q->C:
   [Set a->n.st = COMMIT
    iff a->n->p == a &&
        Q(a)]

C->DP:
   [Set p->n = n
    iff C(a)]
   
DP->DN:
   [Set n->p = p
    iff DP(a)]

DN->D:
   [Set p.st = COMMIT
    iff DN(a)]

C->Q:
   [Set a->n.st = RDY
    iff C(A)]

It's not obvious, but each transition can be done in a single CAS2
operation.

state_of(a):
    n := a->n
    p := a->p
    if(p.st == COMMIT)
        return D
    if(n.st != COMMIT)
        return Q
    np := n->p
    if(n != a->n)
        restart
    if

Q->C:
    n := a->n
    np := n->p
    if n.st == COMMIT || a->p.st == COMMIT
        return
        
    if np != a
        if n != a->n
            return
        [n->p = a iff n->p == np] else return
    [n.st = COMMIT iff n == a] else return

    Let N be the time of n := a->n.
        P the time of the read in a->p.st == COMMIT.

    Lemma 1:
    If n == a->n after the check, then Q(a) at that time:
        Let N2 be the time of n == a->n.

        a->n.st != COMMIT between N and N2, since:
            YADDA
            {n.gen gets a unique value on every write and
             n.gen == a->n.gen at N2}
            YADDA

        a->p.st != COMMIT && a->n.st != COMMIT at P,
            since P is between N and N2

        Q(a) was true at P,
            since only Q(a) allows the last expression to be true.

        Q(a) was true between N and N2,
            since the only transition from Q is Q->C, which writes a->n

        


    Thm:
    The first CAS succeeds only if Q(a) && n->p->p == a:
        Suppose it succeeds:
            Let NP be the time of np := n->p.
                W be a time just before the CAS.
 
            Q(a) at NP, since:
                n == a->n after the check and NP,
                    since the CAS was reached
                Q(a),
                    by lemma 1.

            Q(n) || C(n) at NP:
                by IH2 and Q(a) at NP

            DP(np) at NP:
                np->n == n at NP, 
                    since Q(n) and C(n) both imply it.

                np->p == a at NP, since:
                    [n->p != a at NP,
                        since the CAS was reached
                     and Q(a) requires n->p == a || n->p->p == a]

                DP(np) at NP, 
                    since only DP(np) allows np->n == n && np->p == a.

            DP(np) at W:
                No node but np has Q,
                    by IH3

                np == p->n at W,
                    since the CAS succeeded.

                

            The CAS succeeded, so

            np.gen == p->n.gen at W,
            so no enq happened between NP and W

            

                        

    Thm:
    If the first CAS succeeds, all nodes remain in the same state:

    Thm:        
    The second CAS succeeds only if Q(a) && n->p == a:
        Suppose it succeeds:
            Let W be the time of the second CAS.

            By lemma 1, Q(a) at W.

            By construction, n->p == a between N and W. 

            


        If the first CAS succeeds:
            n->p == np was true, with np != a.
            

        

    The first CAS must 


    Suppose the first CAS succeeds. Then Q(a) must have been true

    If n->p != a but n == a->n, 


    This works because of an important property: every write to a->n 

C->Q
   [Set a->n.st 

Q->C:

With the help of special 
